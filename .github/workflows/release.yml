# Release Workflow
# –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ —Å–æ–∑–¥–∞–Ω–∏–µ —Ä–µ–ª–∏–∑–æ–≤ –∏ —Ä–∞–∑–≤–µ—Ä—Ç—ã–≤–∞–Ω–∏–µ –≤ production

name: Release

on:
  push:
    tags:
      - 'v*.*.*'  # –°–µ–º–∞–Ω—Ç–∏—á–µ—Å–∫–∏–µ –≤–µ—Ä—Å–∏–∏: v1.0.0, v2.1.3, etc.
  workflow_dispatch:
    inputs:
      version:
        description: 'Release version (e.g., v1.0.0)'
        required: true
        type: string

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  # –°–æ–∑–¥–∞–Ω–∏–µ GitHub Release
  create-release:
    runs-on: ubuntu-latest
    outputs:
      upload_url: ${{ steps.create_release.outputs.upload_url }}
      tag_name: ${{ steps.get_version.outputs.tag_name }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Get version
      id: get_version
      run: |
        if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
          echo "tag_name=${{ github.event.inputs.version }}" >> $GITHUB_OUTPUT
        else
          echo "tag_name=${GITHUB_REF#refs/tags/}" >> $GITHUB_OUTPUT
        fi

    - name: Generate changelog
      id: changelog
      run: |
        # –ü–æ–ª—É—á–∞–µ–º –ø—Ä–µ–¥—ã–¥—É—â–∏–π —Ç–µ–≥
        PREVIOUS_TAG=$(git describe --tags --abbrev=0 HEAD~1 2>/dev/null || echo "")
        
        if [ -n "$PREVIOUS_TAG" ]; then
          echo "## Changes since $PREVIOUS_TAG" > CHANGELOG.md
          git log $PREVIOUS_TAG..HEAD --pretty=format:"- %s (%h)" >> CHANGELOG.md
        else
          echo "## Initial Release" > CHANGELOG.md
          git log --pretty=format:"- %s (%h)" >> CHANGELOG.md
        fi
        
        echo "changelog<<EOF" >> $GITHUB_OUTPUT
        cat CHANGELOG.md >> $GITHUB_OUTPUT
        echo "EOF" >> $GITHUB_OUTPUT

    - name: Create Release
      id: create_release
      uses: actions/create-release@v1
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        tag_name: ${{ steps.get_version.outputs.tag_name }}
        release_name: Release ${{ steps.get_version.outputs.tag_name }}
        body: ${{ steps.changelog.outputs.changelog }}
        draft: false
        prerelease: ${{ contains(steps.get_version.outputs.tag_name, '-') }}

  # –°–±–æ—Ä–∫–∞ –∏ –ø—É–±–ª–∏–∫–∞—Ü–∏—è Docker –æ–±—Ä–∞–∑–∞ –¥–ª—è —Ä–µ–ª–∏–∑–∞
  build-release-image:
    needs: create-release
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Log in to Container Registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}

    - name: Extract metadata
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
        tags: |
          type=semver,pattern={{version}}
          type=semver,pattern={{major}}.{{minor}}
          type=semver,pattern={{major}}
          type=raw,value=latest

    - name: Build and push release image
      uses: docker/build-push-action@v5
      with:
        context: .
        platforms: linux/amd64,linux/arm64
        push: true
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}
        cache-from: type=gha
        cache-to: type=gha,mode=max
        build-args: |
          VERSION=${{ needs.create-release.outputs.tag_name }}
          BUILDTIME=${{ fromJSON(steps.meta.outputs.json).labels['org.opencontainers.image.created'] }}
          REVISION=${{ github.sha }}

    - name: Sign container image
      run: |
        # –£—Å—Ç–∞–Ω–æ–≤–∫–∞ cosign –¥–ª—è –ø–æ–¥–ø–∏—Å–∏ –æ–±—Ä–∞–∑–æ–≤
        curl -O -L "https://github.com/sigstore/cosign/releases/latest/download/cosign-linux-amd64"
        sudo mv cosign-linux-amd64 /usr/local/bin/cosign
        sudo chmod +x /usr/local/bin/cosign
        
        # –ü–æ–¥–ø–∏—Å—å –æ–±—Ä–∞–∑–∞
        echo "${{ secrets.COSIGN_PRIVATE_KEY }}" | cosign sign --key - ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.create-release.outputs.tag_name }}
      env:
        COSIGN_PASSWORD: ${{ secrets.COSIGN_PASSWORD }}

  # –†–∞–∑–≤–µ—Ä—Ç—ã–≤–∞–Ω–∏–µ –≤ production
  deploy-production:
    needs: [create-release, build-release-image]
    runs-on: ubuntu-latest
    environment: production
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup kubectl
      uses: azure/setup-kubectl@v3
      with:
        version: 'v1.28.0'

    - name: Configure kubectl
      run: |
        echo "${{ secrets.KUBE_CONFIG_PROD }}" | base64 -d > kubeconfig
        export KUBECONFIG=kubeconfig

    - name: Update production manifests
      run: |
        TAG=${{ needs.create-release.outputs.tag_name }}
        
        # –û–±–Ω–æ–≤–ª—è–µ–º –æ–±—Ä–∞–∑ –≤ –¥–µ–ø–ª–æ–π–º–µ–Ω—Ç–µ
        sed -i "s|sentiment-service:latest|${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${TAG}|g" k8s/deployment.yaml
        
        # –ù–∞—Å—Ç—Ä–æ–π–∫–∏ –¥–ª—è production
        sed -i 's|replicas: 2|replicas: 3|g' k8s/deployment.yaml
        sed -i 's|cpu: "500m"|cpu: "1000m"|g' k8s/deployment.yaml
        sed -i 's|memory: "1Gi"|memory: "2Gi"|g' k8s/deployment.yaml

    - name: Deploy to Production
      run: |
        export KUBECONFIG=kubeconfig
        
        echo "üöÄ Starting production deployment..."
        
        # –ü—Ä–∏–º–µ–Ω—è–µ–º –º–∞–Ω–∏—Ñ–µ—Å—Ç—ã
        kubectl apply -f k8s/namespace.yaml
        kubectl apply -f k8s/configmap.yaml
        kubectl apply -f k8s/deployment.yaml
        kubectl apply -f k8s/service.yaml
        kubectl apply -f k8s/hpa.yaml
        kubectl apply -f k8s/ingress.yaml
        
        # –ñ–¥–µ–º —É—Å–ø–µ—à–Ω–æ–≥–æ —Ä–∞–∑–≤–µ—Ä—Ç—ã–≤–∞–Ω–∏—è
        echo "‚è≥ Waiting for deployment to complete..."
        kubectl rollout status deployment/sentiment-service -n mlops-sentiment --timeout=600s
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ
        echo "üìä Deployment status:"
        kubectl get pods -n mlops-sentiment -o wide
        kubectl get services -n mlops-sentiment

    - name: Production smoke tests
      run: |
        export KUBECONFIG=kubeconfig
        
        # –ü–æ–ª—É—á–∞–µ–º URL —Å–µ—Ä–≤–∏—Å–∞
        INGRESS_IP=$(kubectl get ingress sentiment-ingress -n mlops-sentiment -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
        SERVICE_URL="https://${INGRESS_IP}"
        
        echo "üß™ Running production smoke tests..."
        
        # –ë–∞–∑–æ–≤—ã–µ –ø—Ä–æ–≤–µ—Ä–∫–∏
        curl -f "${SERVICE_URL}/health" || exit 1
        curl -f "${SERVICE_URL}/metrics" || exit 1
        
        # –¢–µ—Å—Ç –ø—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏—è
        curl -X POST "${SERVICE_URL}/predict" \
          -H "Content-Type: application/json" \
          -d '{"text": "This is a test message"}' \
          -f || exit 1
        
        echo "‚úÖ All smoke tests passed!"

    - name: Update release with deployment info
      uses: actions/github-script@v7
      with:
        script: |
          const { data: release } = await github.rest.repos.getReleaseByTag({
            owner: context.repo.owner,
            repo: context.repo.repo,
            tag: '${{ needs.create-release.outputs.tag_name }}'
          });
          
          const deploymentInfo = `
          
          ## üöÄ Deployment Information
          
          **Production Deployment**: ‚úÖ Successfully deployed
          **Image**: \`${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.create-release.outputs.tag_name }}\`
          **Deployed at**: ${new Date().toISOString()}
          **Kubernetes Namespace**: \`mlops-sentiment\`
          
          ### Service Endpoints
          - Health Check: \`/health\`
          - Metrics: \`/metrics\`
          - Prediction API: \`/predict\`
          `;
          
          await github.rest.repos.updateRelease({
            owner: context.repo.owner,
            repo: context.repo.repo,
            release_id: release.id,
            body: release.body + deploymentInfo
          });

  # –£–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –æ —Ä–µ–ª–∏–∑–µ
  notify-release:
    needs: [create-release, deploy-production]
    runs-on: ubuntu-latest
    if: always()
    
    steps:
    - name: Notify Slack about release
      uses: 8398a7/action-slack@v3
      with:
        status: ${{ job.status }}
        channel: '#releases'
        text: |
          üéâ New release deployed!
          **Version**: ${{ needs.create-release.outputs.tag_name }}
          **Status**: ${{ needs.deploy-production.result == 'success' && '‚úÖ Success' || '‚ùå Failed' }}
          **Environment**: Production
          
          View release: https://github.com/${{ github.repository }}/releases/tag/${{ needs.create-release.outputs.tag_name }}
      env:
        SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

    - name: Create Jira release (if configured)
      if: success() && vars.JIRA_PROJECT_KEY
      uses: atlassian/gajira-create-version@v3
      with:
        project: ${{ vars.JIRA_PROJECT_KEY }}
        version: ${{ needs.create-release.outputs.tag_name }}
        description: "Production release ${{ needs.create-release.outputs.tag_name }}"
      env:
        JIRA_BASE_URL: ${{ vars.JIRA_BASE_URL }}
        JIRA_USER_EMAIL: ${{ vars.JIRA_USER_EMAIL }}
        JIRA_API_TOKEN: ${{ secrets.JIRA_API_TOKEN }}
